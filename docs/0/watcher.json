{"dependencies":[{"uri":"file:///home/luiz/programs/dart-sdk/lib/core/core.dart","name":"dart:core","id":"dart.core","children":[{"comment":"\nEverything in Dart is an [Object].\n","uri":"file:///home/luiz/programs/dart-sdk/lib/core/object.dart","name":"Object","id":"Object","children":[{"returnType":{"refId":"dart.core/bool","name":"bool"},"isOperator":true,"comment":"\nThe equality operator.\n\nThe default behavior for all [Object]s is to return true if and\nonly if [:this:] and [other] are the same object.\n\nIf a subclass overrides the equality operator it should override\nthe [hashCode] method as well to maintain consistency.\n","name":"==","id":"==1()","children":[{"name":"other","id":"other","kind":"param"}],"line":"29","kind":"method"},{"returnType":{"refId":"dart.core/String","name":"String"},"comment":"\nReturns a string representation of this object.\n","name":"toString","id":"toString0()","line":"48","kind":"method"},{"comment":"\n[noSuchMethod] is invoked when users invoke a non-existant method\non an object. The name of the method and the arguments of the\ninvocation are passed to [noSuchMethod] in an [Invocation].\nIf [noSuchMethod] returns a value, that value becomes the result of\nthe original invocation.\n\nThe default behavior of [noSuchMethod] is to throw a\n[noSuchMethodError].\n","name":"noSuchMethod","id":"noSuchMethod1()","children":[{"ref":{"refId":"dart.core/Invocation","name":"Invocation"},"name":"invocation","id":"invocation","kind":"param"}],"line":"60","kind":"method"},{"ref":{"refId":"dart.core/int","name":"int"},"comment":"\nGet a hash code for this object.\n\nAll objects have hash codes. Hash codes are guaranteed to be the\nsame for objects that are equal when compared using the equality\noperator [:==:]. Other than that there are no guarantees about\nthe hash codes. They will not be consistent between runs and\nthere are no distribution guarantees.\n\nIf a subclass overrides [hashCode] it should override the\nequality operator as well to maintain consistency.\n","name":"hashCode","id":"hashCode","line":"43","kind":"property"},{"ref":{"refId":"dart.core/Type","name":"Type"},"comment":"\nA representation of the runtime type of the object.\n","name":"runtimeType","id":"runtimeType","line":"65","kind":"property"},{"comment":"\nCreates a new [Object] instance.\n\n[Object] instances have no meaningful state, and are only useful\nthrough their identity. An [Object] instance is equal to itself\nonly.\n","name":"Object","id":"Object0()","line":"18","kind":"constructor"}],"line":"10","kind":"class"}],"line":"5","kind":"library"}],"comment":"\nA library to observe changes on Dart objects.\n\nSimilar to the principle of watchers in AngularJS, this library provides the\nmechanisms to observe and react to changes that happen in an application's\ndata model.\n\nWatchers have a simple lifetime:\n\n  * they are created calling [watch],\n\n  * they are fired whenever [dispatch] is called and the watched values\n  changed since the last time [dispatch] was invoked, and\n\n  * they are unregistered using a function that was returned by [watch] when\n  they were created.\n\nFor example, you can create a watcher that observes changes to a variable by\ncalling [watch] as follows:\n\n    var x = 0;\n    var stop = watch(() => x, (_) => print('hi'));\n\nChanges to the variable 'x' will be detected whenever we call [dispatch]:\n\n    x = 12;\n    x = 13;\n    dispatch(); // the watcher is invoked ('hi' will be printed once).\n\nAfter deregistering the watcher, events are no longer fired:\n\n    stop();\n    x = 14;\n    dispatch(); // nothing happens.\n\nYou can watch several kinds of expressions, including lists. See [watch] for\nmore details.\n\nA common design pattern for MVC applications is to call [dispatch] at the end\nof each event loop (e.g. after each UI event is fired). Our view library does\nthis automatically.\n","uri":"package:web_ui/watcher.dart","name":"package:web_ui/watcher.dart","id":"watcher","children":[{"returnType":{"refId":"void","name":"void"},"comment":"\nScan all registered watchers and invoke their callbacks if the watched value\nhas changed. Because we allow listeners to modify other watched expressions,\n[dispatch] will reiterate until no changes occur or until we reach a\nparticular limit (10) to ensure termination.\n","name":"dispatch","id":"dispatch0()","line":"221","kind":"method"},{"returnType":{"refId":"web_ui.observe.observable/ChangeUnobserver","name":"ChangeUnobserver"},"comment":"\nAdd a watcher for [exp] and immediatly invoke [callback]. The watch event\npassed to [callback] will have `null` as the old value, and the current\nevaluation of [exp] as the new value.\n","name":"watchAndInvoke","id":"watchAndInvoke3()","children":[{"name":"exp","id":"exp","kind":"param"},{"name":"callback","id":"callback","kind":"param"},{"isOptional":true,"name":"debugName","id":"debugName","kind":"param"}],"line":"139","kind":"method"},{"returnType":{"refId":"web_ui.observe.observable/ChangeUnobserver","name":"ChangeUnobserver"},"comment":"\nWatch for changes in [target].  The [callback] function will be called when\n[dispatch] is called and the value represented by [target] had changed.  The\nreturned function can be used to unregister this watcher.\n\nThere are several values you can use for [target]:\n\n  * A [Getter] function.\n  Use this to watch expressions as they change. For instance, to watch\n  whether `a.b.c` changes, wrap it in a getter and call [watch] as follows:\n        watch(() => a.b.c, ...)\n  These targets are tracked to check for equality. If calling `target()`\n  returns the same result, then the [callback] will not be invoked. In the\n  special case whe the getter returns a [List], we will treat the value in a\n  special way, similar to passing [List] directly as [target].\n  **Important**: this library assumes that [Getter] is a read-only function\n  and that it will consistently return the same value if called multiple\n  times in a row.\n\n  * A [List].\n  Use this to watch whether a list object changes. For instance, to detect\n  if an element is added or changed in a list can call [watch] as follows:\n        watch(list, ...)\n\n  * A [Handle].\n  This is syntactic sugar for using the getter portion of a [Handle].\n        watch(handle, ...)  // equivalent to `watch(handle._getter, ...)`\n","name":"watch","id":"watch3()","children":[{"name":"target","id":"target","kind":"param"},{"ref":{"refId":"web_ui.observe.observable/ChangeObserver","name":"ChangeObserver"},"name":"callback","id":"callback","kind":"param"},{"ref":{"refId":"dart.core/String","name":"String"},"isOptional":true,"name":"debugName","id":"debugName","kind":"param"}],"line":"95","kind":"method"},{"ref":{"refId":"dart.core/int","name":"int"},"isFinal":true,"comment":"Bound for the [dispatch] algorithm. ","name":"_maxIter","isPrivate":true,"id":"_maxIter","line":"213","kind":"variable"},{"ref":{"refId":"linked_list/LinkedList","arguments":[{"refId":"watcher/_Watcher","name":"_Watcher"}],"name":"LinkedList"},"comment":"Internal set of active watchers. ","name":"_watchers","isPrivate":true,"id":"_watchers","line":"157","kind":"variable"},{"ref":{"refId":"dart.core/bool","name":"bool"},"comment":"\nTrue to use the [observe] library instead of watchers.\n\nObservers require the [observable] annotation on objects and for collection\ntypes to be observable, such as [ObservableList]. But in return they offer\nbetter performance and more precise change tracking. [dispatch] is not\nrequired with observers, and changes to observable objects are always\ndetected.\n\nCurrently this flag is experimental, but it may be the default in the future.\n","name":"useObservers","id":"useObservers","line":"65","kind":"variable"},{"superclass":{"refId":"watcher/_Watcher","name":"_Watcher"},"comment":"\nA watcher for list objects. It stores as the last value a shallow copy of the\nlist as it was when we last detected any changes.\n","name":"_ListWatcher","isPrivate":true,"id":"_ListWatcher","children":[{"returnType":{"refId":"dart.core/bool","name":"bool"},"name":"_compare","isPrivate":true,"id":"_compare1()","children":[{"ref":{"refId":"dart.core/List","arguments":[{"refId":"watcher/_ListWatcher/T","name":"T"}],"name":"List"},"name":"currentValue","id":"currentValue","kind":"param"}],"line":"302","kind":"method"},{"returnType":{"refId":"void","name":"void"},"name":"_update","isPrivate":true,"id":"_update1()","children":[{"name":"currentValue","id":"currentValue","kind":"param"}],"line":"311","kind":"method"},{"name":"_ListWatcher","id":"_ListWatcher3()","children":[{"name":"getter","id":"getter","kind":"param"},{"ref":{"refId":"web_ui.observe.observable/ChangeObserver","name":"ChangeObserver"},"name":"callback","id":"callback","kind":"param"},{"ref":{"refId":"dart.core/String","name":"String"},"name":"debugName","id":"debugName","kind":"param"}],"line":"297","kind":"constructor"},{"name":"T","id":"T","kind":"typeparam"}],"line":"295","kind":"class"},{"superclass":{"refId":"dart.core/Object","name":"Object"},"comment":"\nAn indirect reference to a value. This is used to create two-way bindings in\nMVC applications.\n\nThe model can be a normal Dart class. You can then create a handle to a\nparticular reference so that the view has read/write access without\ninternally revealing your model abstraction. For example, consider a model\nclass containing whether or not an item is 'checked' on a list:\n\n    class Item {\n      int id;\n      ...\n      bool checked;\n\nThen we can use a CheckBox view and only reveal the status of the checked\nfield as follows:\n\n    new CheckBoxView(new Handle<bool>(\n        () => item.checked,\n        (v) { item.checked = v}));\n\nA handle with no setter is a read-only handle.\n","name":"Handle","id":"Handle","children":[{"returnType":{"refId":"void","name":"void"},"isSetter":true,"name":"value=","id":"value=1()","children":[{"ref":{"refId":"watcher/Handle/T","name":"T"},"name":"value","id":"value","kind":"param"}],"line":"282","kind":"method"},{"ref":{"refId":"watcher/Handle/T","name":"T"},"name":"value","id":"value","line":"280","kind":"property"},{"ref":{"refId":"watcher/Getter","name":"Getter"},"isFinal":true,"name":"_getter","isPrivate":true,"id":"_getter","line":"272","kind":"variable"},{"ref":{"refId":"watcher/Setter","name":"Setter"},"isFinal":true,"name":"_setter","isPrivate":true,"id":"_setter","line":"273","kind":"variable"},{"comment":"Create a handle, possibly read-only (if no setter is specified). ","name":"Handle","id":"Handle2()","children":[{"initializedField":{"refId":"watcher/Handle/_getter","name":"_getter"},"ref":{"refId":"watcher/Getter","name":"Getter"},"name":"_getter","isPrivate":true,"id":"_getter","kind":"param"},{"initializedField":{"refId":"watcher/Handle/_setter","name":"_setter"},"ref":{"refId":"watcher/Setter","name":"Setter"},"isOptional":true,"name":"_setter","isPrivate":true,"id":"_setter","kind":"param"}],"line":"276","kind":"constructor"},{"name":"Handle.of","id":"Handle.of1()","children":[{"ref":{"refId":"watcher/Handle/T","name":"T"},"name":"value","id":"value","kind":"param"}],"line":"278","kind":"constructor"},{"name":"T","id":"T","kind":"typeparam"}],"line":"271","kind":"class"},{"returnType":{"refId":"void","name":"void"},"comment":"An indirect setter. ","name":"Setter","id":"Setter","children":[{"ref":{"refId":"watcher/Setter/T","name":"T"},"name":"value","id":"value","kind":"param"},{"name":"T","id":"T","kind":"typeparam"}],"line":"246","kind":"typedef"},{"returnType":{"refId":"watcher/Getter/T","name":"T"},"comment":"\nAn indirect getter. Basically a simple closure that returns a value, which is\nthe most common argument in [watch].\n","name":"Getter","id":"Getter","children":[{"name":"T","id":"T","kind":"typeparam"}],"line":"243","kind":"typedef"},{"superclass":{"refId":"dart.core/Object","name":"Object"},"comment":"\nAn internal representation of a watcher. Contains the expression it watches,\nthe last value seen for it, and a callback to invoke when a change is\ndetected.\n","name":"_Watcher","isPrivate":true,"id":"_Watcher","children":[{"returnType":{"refId":"dart.core/String","name":"String"},"name":"toString","id":"toString0()","line":"181","kind":"method"},{"returnType":{"refId":"dart.core/bool","name":"bool"},"comment":"Detect if any changes occurred and if so invoke [_callback]. ","name":"compareAndNotify","id":"compareAndNotify0()","line":"184","kind":"method"},{"returnType":{"refId":"dart.core/bool","name":"bool"},"name":"_compare","isPrivate":true,"id":"_compare1()","children":[{"name":"currentValue","id":"currentValue","kind":"param"}],"line":"195","kind":"method"},{"returnType":{"refId":"void","name":"void"},"name":"_update","isPrivate":true,"id":"_update1()","children":[{"name":"currentValue","id":"currentValue","kind":"param"}],"line":"197","kind":"method"},{"comment":"Read [_getter] but detect whether exceptions were thrown. ","name":"_safeRead","isPrivate":true,"id":"_safeRead0()","line":"202","kind":"method"},{"ref":{"refId":"dart.core/String","name":"String"},"isFinal":true,"comment":"Name used to debug. ","name":"debugName","id":"debugName","line":"166","kind":"variable"},{"ref":{"refId":"watcher/Getter","name":"Getter"},"isFinal":true,"comment":"Function that retrieves the value being watched. ","name":"_getter","isPrivate":true,"id":"_getter","line":"169","kind":"variable"},{"ref":{"refId":"web_ui.observe.observable/ChangeObserver","name":"ChangeObserver"},"isFinal":true,"comment":"Callback to invoke when the value changes. ","name":"_callback","isPrivate":true,"id":"_callback","line":"172","kind":"variable"},{"comment":"Last value observed on the matched expression. ","name":"_lastValue","isPrivate":true,"id":"_lastValue","line":"175","kind":"variable"},{"name":"_Watcher","id":"_Watcher3()","children":[{"initializedField":{"refId":"watcher/_Watcher/_getter","name":"_getter"},"ref":{"refId":"watcher/Getter","name":"Getter"},"name":"_getter","isPrivate":true,"id":"_getter","kind":"param"},{"initializedField":{"refId":"watcher/_Watcher/_callback","name":"_callback"},"ref":{"refId":"web_ui.observe.observable/ChangeObserver","name":"ChangeObserver"},"name":"_callback","isPrivate":true,"id":"_callback","kind":"param"},{"initializedField":{"refId":"watcher/_Watcher/debugName","name":"debugName"},"ref":{"refId":"dart.core/String","name":"String"},"name":"debugName","id":"debugName","kind":"param"}],"line":"177","kind":"constructor"}],"line":"164","kind":"class"}],"line":"47","kind":"library"}