{"dependencies":[{"uri":"file:///home/luiz/programs/dart-sdk/lib/core/core.dart","name":"dart:core","id":"dart.core","children":[{"comment":"\nEverything in Dart is an [Object].\n","uri":"file:///home/luiz/programs/dart-sdk/lib/core/object.dart","name":"Object","id":"Object","children":[{"returnType":{"refId":"dart.core/bool","name":"bool"},"isOperator":true,"comment":"\nThe equality operator.\n\nThe default behavior for all [Object]s is to return true if and\nonly if [:this:] and [other] are the same object.\n\nIf a subclass overrides the equality operator it should override\nthe [hashCode] method as well to maintain consistency.\n","name":"==","id":"==1()","children":[{"name":"other","id":"other","kind":"param"}],"line":"29","kind":"method"},{"returnType":{"refId":"dart.core/String","name":"String"},"comment":"\nReturns a string representation of this object.\n","name":"toString","id":"toString0()","line":"48","kind":"method"},{"comment":"\n[noSuchMethod] is invoked when users invoke a non-existant method\non an object. The name of the method and the arguments of the\ninvocation are passed to [noSuchMethod] in an [Invocation].\nIf [noSuchMethod] returns a value, that value becomes the result of\nthe original invocation.\n\nThe default behavior of [noSuchMethod] is to throw a\n[noSuchMethodError].\n","name":"noSuchMethod","id":"noSuchMethod1()","children":[{"ref":{"refId":"dart.core/Invocation","name":"Invocation"},"name":"invocation","id":"invocation","kind":"param"}],"line":"60","kind":"method"},{"ref":{"refId":"dart.core/int","name":"int"},"comment":"\nGet a hash code for this object.\n\nAll objects have hash codes. Hash codes are guaranteed to be the\nsame for objects that are equal when compared using the equality\noperator [:==:]. Other than that there are no guarantees about\nthe hash codes. They will not be consistent between runs and\nthere are no distribution guarantees.\n\nIf a subclass overrides [hashCode] it should override the\nequality operator as well to maintain consistency.\n","name":"hashCode","id":"hashCode","line":"43","kind":"property"},{"ref":{"refId":"dart.core/Type","name":"Type"},"comment":"\nA representation of the runtime type of the object.\n","name":"runtimeType","id":"runtimeType","line":"65","kind":"property"},{"comment":"\nCreates a new [Object] instance.\n\n[Object] instances have no meaningful state, and are only useful\nthrough their identity. An [Object] instance is equal to itself\nonly.\n","name":"Object","id":"Object0()","line":"18","kind":"constructor"}],"line":"10","kind":"class"}],"line":"5","kind":"library"}],"comment":"\nThis library is used to implement [Observable] types.\n\nIt exposes lower level functionality such as [hasObservers], [observeReads]\n[notifyChange] and [notifyRead].\n\nUnless you are mixing in [Observable], it is usually better to write:\n\n    import 'package:web_ui/observe.dart';\n","uri":"file:///home/luiz/work/moving_castles/packages/web_ui/observe/observable.dart","name":"file:///home/luiz/work/moving_castles/packages/web_ui/observe/observable.dart","id":"web_ui.observe.observable","children":[{"returnType":{"refId":"void","name":"void"},"comment":"The default handler for [onObserveUnhandledError]. Prints the error. ","name":"defaultObserveUnhandledError","id":"defaultObserveUnhandledError4()","children":[{"name":"error","id":"error","kind":"param"},{"name":"trace","id":"trace","kind":"param"},{"name":"obj","id":"obj","kind":"param"},{"ref":{"refId":"dart.core/String","name":"String"},"name":"message","id":"message","kind":"param"}],"line":"678","kind":"method"},{"returnType":{"refId":"void","name":"void"},"comment":"\nAttempt to provide diagnostics about what change is causing a loop in\nobservers. Unfortunately it is hard to help the programmer unless they have\nprovided a `debugName` to [observe], as callbacks are hard to debug\nbecause of <http://dartbug.com/8419>. However we can print the records that\nchanged which has proved helpful.\n","name":"_diagnoseCircularLimit","isPrivate":true,"id":"_diagnoseCircularLimit2()","children":[{"ref":{"refId":"dart.core/List","arguments":[{"refId":"web_ui.observe.observable/Observable","name":"Observable"}],"name":"List"},"name":"changedObjects","id":"changedObjects","kind":"param"},{"ref":{"refId":"dart.core/Map","arguments":[{"refId":"dart.core/int","name":"int"},{"refId":"web_ui.observe.observable/_ExpressionObserver","name":"_ExpressionObserver"}],"name":"Map"},"name":"changedExpressions","id":"changedExpressions","line":"449","kind":"param"}],"line":"448","kind":"method"},{"returnType":{"refId":"void","name":"void"},"comment":"\nDelivers observed changes immediately. Normally you should not call this\ndirectly, but it can be used to force synchronous delivery, which helps in\ncertain cases like testing.\n\nNote: this will continue delivering changes as long as some are pending and\n[circularNotifyLimit] has not been reached.\n","name":"deliverChangesSync","id":"deliverChangesSync0()","line":"396","kind":"method"},{"returnType":{"refId":"void","name":"void"},"name":"_doNothing","isPrivate":true,"id":"_doNothing0()","line":"357","kind":"method"},{"returnType":{"refId":"void","name":"void"},"comment":"\nNotify that a [key] of [self] has been changed.\n\nThe key can also represent a field or indexed value of the object or list.\nThe [type] is one of the constants [ChangeRecord.INDEX],\n[ChangeRecord.FIELD], [ChangeRecord.INSERT], or [ChangeRecord.REMOVE].\n\nThe [oldValue] and [newValue] are also recorded. If the change wasn't an\ninsert or remove, and the two values are equal, no change will be recorded.\nFor INSERT, oldValue should be null. For REMOVE, newValue should be null.\n\nNote: this is used by objects implementing [Observable].\nYou should not need it if your type is marked `@observable`.\n","name":"notifyChange","id":"notifyChange5()","children":[{"ref":{"refId":"web_ui.observe.observable/Observable","name":"Observable"},"name":"self","id":"self","kind":"param"},{"ref":{"refId":"dart.core/int","name":"int"},"name":"type","id":"type","kind":"param"},{"name":"key","id":"key","kind":"param"},{"ref":{"refId":"dart.core/Object","name":"Object"},"name":"oldValue","id":"oldValue","line":"336","kind":"param"},{"ref":{"refId":"dart.core/Object","name":"Object"},"name":"newValue","id":"newValue","line":"336","kind":"param"}],"line":"335","kind":"method"},{"returnType":{"refId":"void","name":"void"},"comment":"\nNotify that a [key] of [self] has been read. The key can also represent\na field or indexed value of an the object or list.\n\nNote: this is used by objects implementing [Observable].\nYou should not need it if your type is marked `@observable`.\n","name":"notifyRead","id":"notifyRead3()","children":[{"ref":{"refId":"web_ui.observe.observable/Observable","name":"Observable"},"name":"self","id":"self","kind":"param"},{"ref":{"refId":"dart.core/int","name":"int"},"name":"type","id":"type","kind":"param"},{"name":"key","id":"key","kind":"param"}],"line":"318","kind":"method"},{"returnType":{"refId":"dart.core/bool","name":"bool"},"comment":"\nTrue if we are observing reads. This should be checked before calling\n[notifyRead].\n\nNote: this is used by objects implementing [Observable].\nYou should not need it if your type is marked `@observable`.\n","name":"observeReads","id":"observeReads0()","line":"309","kind":"method"},{"returnType":{"refId":"dart.core/bool","name":"bool"},"comment":"\nTrue if [self] has any observers, and should call [notifyChange] for\nchanges.\n\nNote: this is used by objects implementing [Observable].\nYou should not need it if your type is marked `@observable`.\n","name":"hasObservers","id":"hasObservers1()","children":[{"ref":{"refId":"web_ui.observe.observable/Observable","name":"Observable"},"name":"self","id":"self","kind":"param"}],"line":"299","kind":"method"},{"comment":"\nConverts the [Iterable], [Set] or [Map] to an [ObservableList],\n[ObservableSet] or [ObservableMap] respectively.\n\nThe resulting object will contain a shallow copy of the data.\nIf [value] is not one of those collection types, it will be returned\nunmodified.\n\nIf [value] is a [Map], the resulting value will use the appropriate kind of\nbacking map: either [HashMap], [LinkedHashMap], or [SplayTreeMap].\n","name":"toObservable","id":"toObservable1()","children":[{"name":"value","id":"value","kind":"param"}],"line":"245","kind":"method"},{"returnType":{"refId":"web_ui.observe.observable/ChangeUnobserver","name":"ChangeUnobserver"},"comment":"\nObserves the object and delivers asynchronous notifications of changes\nto the observer.\n\nChanges will be delivered when any field, index, or key changes its value.\nThe field is considered to have changed if the values no longer compare\nequal via the equality operator.\n\nIf you wish to observe a function, use [observe] instead.\n\nReturns a function that can be used to stop observation.\nCalling this makes it possible for the garbage collector to reclaim memory\nassociated with the observation and prevents further calls to [callback].\n\nYou can force a synchronous change delivery at any time by calling\n[deliverChangesSync]. Calling this method if there are no changes has no\neffect. If changes are delivered by deliverChangesSync, they will not be\ndelivered again asynchronously, unless the value is changed again.\n","name":"observeChanges","id":"observeChanges2()","children":[{"ref":{"refId":"web_ui.observe.observable/Observable","name":"Observable"},"name":"obj","id":"obj","kind":"param"},{"ref":{"refId":"web_ui.observe.observable/ChangeRecordObserver","name":"ChangeRecordObserver"},"name":"observer","id":"observer","kind":"param"}],"line":"227","kind":"method"},{"returnType":{"refId":"web_ui.observe.observable/ChangeUnobserver","name":"ChangeUnobserver"},"comment":"\nObserves the value and delivers asynchronous notifications of changes\nto the [callback].\n\nThe [value] should be either an [ObservableExpression] or a [Observable].\n\nIf the value is an expression, it is considered to have changed if the result\nno longer compares equal via the equality operator. You can perform\nadditional comparisons in the [callback] if desired, using\n[ChangeNotification.oldValue] and [ChangeNotification.newValue].\n\nIf the value is [Observable] it will be observed, and considered to have\nchanged if any change is signaled. In this case the oldValue and newValue\nwill be the same. Use [observeChanges] instead if you want the list of\n[ChangeRecord]s for that object.\n\nThis returns a function that can be used to stop observation.\nCalling this makes it possible for the garbage collector to reclaim memory\nassociated with the observation and prevents further calls to [callback].\n\nBecause notifications are delivered asynchronously and batched, the callback\nwill only be run once for all changes that were made since the last time it\nwas run.\n\nYou can force a synchronous change delivery at any time by calling\n[deliverChangesSync]. Calling this method if there are no changes has no\neffect. If changes are delivered by deliverChangesSync, they will not be\ndelivered again asynchronously, unless the value is changed again.\n\nAny errors thrown by [expression] and [callback] will be caught and sent to\n[onObserveUnhandledError].\n","name":"observe","id":"observe3()","children":[{"name":"value","id":"value","kind":"param"},{"ref":{"refId":"web_ui.observe.observable/ChangeObserver","name":"ChangeObserver"},"name":"callback","id":"callback","kind":"param"},{"ref":{"refId":"dart.core/String","name":"String"},"isOptional":true,"name":"debugName","id":"debugName","kind":"param"}],"line":"188","kind":"method"},{"ref":{"refId":"dart.core/bool","name":"bool"},"comment":"\nTrue if we are observing reads. This should be checked before calling\n[notifyRead].\n\nNote: this is used by objects implementing [Observable].\nYou should not need it if your type is marked `@observable`.\n","name":"observeReads","id":"observeReads","line":"309","kind":"property"},{"ref":{"refId":"web_ui.observe.observable/ObserverErrorHandler","name":"ObserverErrorHandler"},"comment":"\nCallback to intercept unhandled errors in evaluating an observable.\nIncludes the error, stack trace, and information about what caused the error.\nBy default it will use [defaultObserveUnhandledError], which prints the\nerror.\n","name":"onObserveUnhandledError","id":"onObserveUnhandledError","line":"675","kind":"variable"},{"ref":{"refId":"web_ui.observe.observable/CircularNotifyLimitHandler","name":"CircularNotifyLimitHandler"},"comment":"\nFunction that is called when change notifications get stuck in a circular\nloop, which can happen if one [ChangeObserver] causes another change to\nhappen, and that change causes another, etc.\n\nThis is called when [circularNotifyLimit] is reached by\n[deliverChangesSync]. Circular references are commonly the result of not\ncorrectly implementing equality for objects.\n\nThe default behavior is to print the message.\n","name":"onCircularNotifyLimit","id":"onCircularNotifyLimit","line":"661","kind":"variable"},{"ref":{"refId":"dart.collection/SplayTreeMap","arguments":[{"refId":"dart.core/num","name":"num"},{"refId":"web_ui.observe.observable/_ExpressionObserver","name":"_ExpressionObserver"}],"name":"SplayTreeMap"},"comment":"The per-isolate list of possibly changed expressions. ","name":"_changedExpressions","isPrivate":true,"id":"_changedExpressions","line":"386","kind":"variable"},{"ref":{"refId":"dart.core/List","arguments":[{"refId":"web_ui.observe.observable/Observable","name":"Observable"}],"name":"List"},"comment":"The per-isolate list of changed objects. ","name":"_changedObjects","isPrivate":true,"id":"_changedObjects","line":"379","kind":"variable"},{"ref":{"refId":"dart.core/int","name":"int"},"comment":"\nThe limit of times we will attempt to deliver a set of pending changes.\n\n[deliverChangesSync] will attempt to deliver pending changes until there are\nno more. If one of the pending changes causes another batch of changes, it\nwill iterate again and increment the iteration counter. Once it reaches\nthis limit it will call [onCircularNotifyLimit].\n\nNote that there is no limit to the number of changes per batch, only to the\nnumber of iterations.\n","name":"circularNotifyLimit","id":"circularNotifyLimit","line":"376","kind":"variable"},{"ref":{"refId":"web_ui.observe.observable/_ExpressionObserver","name":"_ExpressionObserver"},"comment":"\nThe current observer that is tracking reads, or null if we aren't tracking\nreads. Reads are tracked when executing [_ExpressionObserver._observe].\n","name":"_activeObserver","isPrivate":true,"id":"_activeObserver","line":"363","kind":"variable"},{"comment":"\nUse `@observable` to make a class observable. All fields in the class will\nbe transformed to track changes. The overhead will be minimal unless they are\nactually being observed.\n","name":"observable","id":"observable","line":"30","kind":"variable"},{"superclass":{"refId":"dart.core/Object","name":"Object"},"comment":"\nThe type of the `@observable` annotation.\n\nLibrary private because you should be able to use the [observable] field\nto get the one and only instance. We could make it public though, if anyone\nneeds it for some reason.\n","name":"_ObservableAnnotation","isPrivate":true,"id":"_ObservableAnnotation","children":[{"name":"_ObservableAnnotation","id":"_ObservableAnnotation0()","line":"694","kind":"constructor"}],"line":"693","kind":"class"},{"returnType":{"refId":"void","name":"void"},"comment":"\nA function that handles an [error] given the [stackTrace] that caused the\nerror. The other arguments provide additional context about the error.\n","name":"ObserverErrorHandler","id":"ObserverErrorHandler","children":[{"name":"error","id":"error","kind":"param"},{"name":"stackTrace","id":"stackTrace","kind":"param"},{"name":"obj","id":"obj","kind":"param"},{"ref":{"refId":"dart.core/String","name":"String"},"name":"message","id":"message","kind":"param"}],"line":"667","kind":"typedef"},{"returnType":{"refId":"void","name":"void"},"name":"CircularNotifyLimitHandler","id":"CircularNotifyLimitHandler","children":[{"ref":{"refId":"dart.core/String","name":"String"},"name":"message","id":"message","kind":"param"}],"line":"646","kind":"typedef"},{"superclass":{"refId":"dart.core/Object","name":"Object"},"name":"_ExpressionObserver","isPrivate":true,"id":"_ExpressionObserver","children":[{"returnType":{"refId":"dart.core/String","name":"String"},"name":"toString","id":"toString0()","line":"516","kind":"method"},{"returnType":{"refId":"dart.core/bool","name":"bool"},"name":"_observe","isPrivate":true,"id":"_observe0()","line":"519","kind":"method"},{"returnType":{"refId":"void","name":"void"},"name":"_runCallback","isPrivate":true,"id":"_runCallback1()","children":[{"ref":{"refId":"web_ui.observe.observable/ChangeNotification","name":"ChangeNotification"},"name":"change","id":"change","kind":"param"}],"line":"554","kind":"method"},{"returnType":{"refId":"void","name":"void"},"name":"_observeValue","isPrivate":true,"id":"_observeValue0()","line":"563","kind":"method"},{"returnType":{"refId":"void","name":"void"},"name":"_addRead","isPrivate":true,"id":"_addRead3()","children":[{"ref":{"refId":"web_ui.observe.observable/Observable","name":"Observable"},"name":"target","id":"target","kind":"param"},{"ref":{"refId":"dart.core/int","name":"int"},"name":"type","id":"type","kind":"param"},{"name":"key","id":"key","kind":"param"}],"line":"572","kind":"method"},{"returnType":{"refId":"void","name":"void"},"name":"_watchForChange","isPrivate":true,"id":"_watchForChange2()","children":[{"ref":{"refId":"web_ui.observe.observable/Observable","name":"Observable"},"name":"target","id":"target","kind":"param"},{"ref":{"refId":"dart.core/Map","arguments":[{"refId":"dart.core/Object","name":"Object"},{"refId":"dart.core/int","name":"int"}],"name":"Map"},"name":"reads","id":"reads","kind":"param"}],"line":"587","kind":"method"},{"returnType":{"refId":"void","name":"void"},"name":"_unobserve","isPrivate":true,"id":"_unobserve0()","line":"604","kind":"method"},{"returnType":{"refId":"web_ui.observe.observable/ChangeNotification","name":"ChangeNotification"},"name":"_deliver","isPrivate":true,"id":"_deliver0()","line":"622","kind":"method"},{"ref":{"refId":"dart.core/bool","name":"bool"},"comment":"True if this observer has been unobserved. ","name":"_dead","isPrivate":true,"id":"_dead","line":"514","kind":"property"},{"ref":{"refId":"dart.core/int","name":"int"},"isStatic":true,"name":"_nextId","isPrivate":true,"id":"_nextId","line":"481","kind":"variable"},{"ref":{"refId":"dart.core/int","name":"int"},"isFinal":true,"comment":"\nThe ID indicating creation order. We will call observers in ID order.\nSee the TODO in [deliverChangesSync].\n","name":"_id","isPrivate":true,"id":"_id","line":"487","kind":"variable"},{"ref":{"refId":"web_ui.observe.observable/ObservableExpression","name":"ObservableExpression"},"isFinal":true,"name":"_expression","isPrivate":true,"id":"_expression","line":"489","kind":"variable"},{"ref":{"refId":"web_ui.observe.observable/ChangeObserver","name":"ChangeObserver"},"isFinal":true,"name":"_callback","isPrivate":true,"id":"_callback","line":"491","kind":"variable"},{"ref":{"refId":"dart.core/String","name":"String"},"isFinal":true,"comment":"\nThe name used for debugging. This will be removed once Dart has\nbetter debugging of callbacks.\n","name":"_debugName","isPrivate":true,"id":"_debugName","line":"497","kind":"variable"},{"ref":{"refId":"dart.core/Map","arguments":[{"refId":"web_ui.observe.observable/Observable","name":"Observable"},{"refId":"dart.core/Map","arguments":[{"refId":"dart.core/Object","name":"Object"},{"refId":"dart.core/int","name":"int"}],"name":"Map"}],"name":"Map"},"isFinal":true,"name":"_reads","isPrivate":true,"id":"_reads","line":"500","kind":"variable"},{"ref":{"refId":"dart.core/List","arguments":[{"refId":"web_ui.observe.observable/ChangeUnobserver","name":"ChangeUnobserver"}],"name":"List"},"isFinal":true,"name":"_unobservers","isPrivate":true,"id":"_unobservers","line":"502","kind":"variable"},{"ref":{"refId":"dart.core/bool","name":"bool"},"name":"_scheduled","isPrivate":true,"id":"_scheduled","line":"504","kind":"variable"},{"ref":{"refId":"dart.core/Object","name":"Object"},"comment":"The last value of this observable. ","name":"_value","isPrivate":true,"id":"_value","line":"507","kind":"variable"},{"name":"_ExpressionObserver","id":"_ExpressionObserver3()","children":[{"initializedField":{"refId":"web_ui.observe.observable/_ExpressionObserver/_expression","name":"_expression"},"ref":{"refId":"web_ui.observe.observable/ObservableExpression","name":"ObservableExpression"},"name":"_expression","isPrivate":true,"id":"_expression","kind":"param"},{"initializedField":{"refId":"web_ui.observe.observable/_ExpressionObserver/_callback","name":"_callback"},"ref":{"refId":"web_ui.observe.observable/ChangeObserver","name":"ChangeObserver"},"name":"_callback","isPrivate":true,"id":"_callback","kind":"param"},{"initializedField":{"refId":"web_ui.observe.observable/_ExpressionObserver/_debugName","name":"_debugName"},"ref":{"refId":"dart.core/String","name":"String"},"name":"_debugName","isPrivate":true,"id":"_debugName","kind":"param"}],"line":"509","kind":"constructor"}],"line":"480","kind":"class"},{"superclass":{"refId":"dart.core/Object","name":"Object"},"comment":"\nAn observable object. This is used by data in model-view architectures\nto notify interested parties of changes.\n\nMost of the methods for observation are static methods to keep them\nstratified from the objects being observed. This is a similar to the design\nof Mirrors.\n","name":"Observable","id":"Observable","children":[{"comment":"Observers for this object. Uses a linked-list for fast removal. ","name":"$_observers","id":"$_observers","line":"274","kind":"variable"},{"ref":{"refId":"dart.core/List","arguments":[{"refId":"web_ui.observe.observable/ChangeRecord","name":"ChangeRecord"}],"name":"List"},"comment":"Changes to this object since last batch was delivered. ","name":"$_changes","id":"$_changes","line":"277","kind":"variable"},{"ref":{"refId":"dart.core/int","name":"int"},"isFinal":true,"name":"hashCode","id":"hashCode","line":"279","kind":"variable"},{"ref":{"refId":"dart.core/int","name":"int"},"isStatic":true,"name":"$_nextHashCode","id":"$_nextHashCode","line":"283","kind":"variable"}],"line":"268","kind":"class"},{"superclass":{"refId":"dart.core/Object","name":"Object"},"comment":"Records a change to an [Observable]. ","name":"ChangeRecord","id":"ChangeRecord","children":[{"returnType":{"refId":"dart.core/bool","name":"bool"},"isOperator":true,"name":"==","id":"==1()","children":[{"name":"other","id":"other","kind":"param"}],"line":"134","kind":"method"},{"returnType":{"refId":"dart.core/String","name":"String"},"name":"toString","id":"toString0()","line":"141","kind":"method"},{"ref":{"refId":"dart.core/int","name":"int"},"name":"hashCode","id":"hashCode","line":"139","kind":"property"},{"isStatic":true,"comment":"[type] denoting set of a field. ","name":"FIELD","id":"FIELD","line":"96","kind":"variable"},{"isStatic":true,"comment":"[type] denoting an in-place update event using `[]=`. ","name":"INDEX","id":"INDEX","line":"100","kind":"variable"},{"isStatic":true,"comment":"\n[type] denoting an insertion into a list. Insertions prepend in front of\nthe given index, so insert at 0 means an insertion at the beginning of the\nlist. The index will be provided in [name].\n","name":"INSERT","id":"INSERT","line":"107","kind":"variable"},{"isStatic":true,"comment":"[type] denoting a remove from a list. ","name":"REMOVE","id":"REMOVE","line":"110","kind":"variable"},{"ref":{"refId":"dart.core/int","name":"int"},"isFinal":true,"comment":"Whether the change was a [FIELD], [INDEX], [INSERT], or [REMOVE]. ","name":"type","id":"type","line":"113","kind":"variable"},{"isFinal":true,"comment":"\nThe key that changed. The value depends on the [type] of change:\n\n- [FIELD]: the field name that was set.\n- [INDEX], [INSERT], and [REMOVE]: the index or key that was changed.\n  This will be an integer for [ObservableList] but can be anything for\n  [ObservableMap] or [ObservableSet].\n","name":"key","id":"key","line":"123","kind":"variable"},{"isFinal":true,"comment":"The previous value of the member. ","name":"oldValue","id":"oldValue","line":"126","kind":"variable"},{"isFinal":true,"comment":"The new value of the member. ","name":"newValue","id":"newValue","line":"129","kind":"variable"},{"name":"ChangeRecord","id":"ChangeRecord4()","children":[{"initializedField":{"refId":"web_ui.observe.observable/ChangeRecord/type","name":"type"},"ref":{"refId":"dart.core/int","name":"int"},"name":"type","id":"type","kind":"param"},{"initializedField":{"refId":"web_ui.observe.observable/ChangeRecord/key","name":"key"},"name":"key","id":"key","kind":"param"},{"initializedField":{"refId":"web_ui.observe.observable/ChangeRecord/oldValue","name":"oldValue"},"name":"oldValue","id":"oldValue","kind":"param"},{"initializedField":{"refId":"web_ui.observe.observable/ChangeRecord/newValue","name":"newValue"},"name":"newValue","id":"newValue","kind":"param"}],"line":"131","kind":"constructor"}],"line":"85","kind":"class"},{"superclass":{"refId":"dart.core/Object","name":"Object"},"comment":"\nA notification of a change to an [ObservableExpression] that is passed to a\n[ChangeObserver].\n","name":"ChangeNotification","id":"ChangeNotification","children":[{"returnType":{"refId":"dart.core/bool","name":"bool"},"isOperator":true,"name":"==","id":"==1()","children":[{"name":"other","id":"other","kind":"param"}],"line":"71","kind":"method"},{"returnType":{"refId":"dart.core/String","name":"String"},"name":"toString","id":"toString0()","line":"78","kind":"method"},{"ref":{"refId":"dart.core/int","name":"int"},"name":"hashCode","id":"hashCode","line":"76","kind":"property"},{"isFinal":true,"comment":"Previous value seen on the watched expression. ","name":"oldValue","id":"oldValue","line":"52","kind":"variable"},{"isFinal":true,"comment":"New value seen on the watched expression. ","name":"newValue","id":"newValue","line":"55","kind":"variable"},{"ref":{"refId":"dart.core/List","arguments":[{"refId":"web_ui.observe.observable/ChangeRecord","name":"ChangeRecord"}],"name":"List"},"isFinal":true,"comment":"\nChange records for this object, or null. This property will be non-null\nif [oldValue] and [newValue] are the same [Observable] object, but we\nobserved changes to the value itself.\n\nThese records can be used for more efficient updates. For example if\nupdating a list of items, only new items can be rendered instead of\ngenerating all of the content again.\n","name":"changes","id":"changes","line":"66","kind":"variable"},{"name":"ChangeNotification","id":"ChangeNotification3()","children":[{"initializedField":{"refId":"web_ui.observe.observable/ChangeNotification/oldValue","name":"oldValue"},"name":"oldValue","id":"oldValue","kind":"param"},{"initializedField":{"refId":"web_ui.observe.observable/ChangeNotification/newValue","name":"newValue"},"name":"newValue","id":"newValue","kind":"param"},{"initializedField":{"refId":"web_ui.observe.observable/ChangeNotification/changes","name":"changes"},"ref":{"refId":"dart.core/List","arguments":[{"refId":"web_ui.observe.observable/ChangeRecord","name":"ChangeRecord"}],"name":"List"},"isOptional":true,"name":"changes","id":"changes","kind":"param"}],"line":"68","kind":"constructor"}],"line":"49","kind":"class"},{"returnType":{"refId":"dart.core/Object","name":"Object"},"comment":"A function that computes a value. ","name":"ObservableExpression","id":"ObservableExpression","line":"42","kind":"typedef"},{"returnType":{"refId":"void","name":"void"},"comment":"A function that unregisters the [ChangeObserver]. ","name":"ChangeUnobserver","id":"ChangeUnobserver","line":"39","kind":"typedef"},{"returnType":{"refId":"void","name":"void"},"comment":"Callback fired when an [Observable] changes. ","name":"ChangeRecordObserver","id":"ChangeRecordObserver","children":[{"ref":{"refId":"dart.core/List","arguments":[{"refId":"web_ui.observe.observable/ChangeRecord","name":"ChangeRecord"}],"name":"List"},"name":"changes","id":"changes","kind":"param"}],"line":"36","kind":"typedef"},{"returnType":{"refId":"void","name":"void"},"comment":"Callback fired when an expression changes. ","name":"ChangeObserver","id":"ChangeObserver","children":[{"ref":{"refId":"web_ui.observe.observable/ChangeNotification","name":"ChangeNotification"},"name":"e","id":"e","kind":"param"}],"line":"33","kind":"typedef"}],"line":"15","kind":"library"}